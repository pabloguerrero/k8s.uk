
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>
k8s.uk
</title>

    <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    
    <link rel="shortcut icon" href="/static/favicon.ico" />
    

    
<link rel="stylesheet" href="/static/css/bootstrap.min.css">
<link rel="stylesheet" href="/static/css/style.css">
<link href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css" rel="stylesheet">


    
  </head>

  <body>
    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">k8s.uk</a>
        </div>
        <nav class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/archive.html">Archive</a></li>
            <li><a href="/pages/about.html">About</a></li>
          </ul>
        </nav>
      </div>
    </div>

    <div class="container">
      
<div class="col-lg-9">
  

  
  <article>
  <h1><a id="kubectl-vs-http-api.html" href="kubectl-vs-http-api.html">Kubectl vs HTTP API</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2016-06-09</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/security.html">security</a>
  
  <a class="label label-info" href="/tag/api.html">api</a>
  
  <a class="label label-info" href="/tag/utils.html">utils</a>
  
  
  </p>

  <p>One of the best things Kubernetes has is its API, however, I&rsquo;ve seen a few tools that instead of using the HTTP API use a wrapper on <code>kubectl</code>. I tweeted about it and a discussion was created around the differences between <code>kubectl</code> and the <code>HTTP API</code>.</p>

<p>This is the tweet:</p>

<p><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">I makes me a bit sad to see tooling around <code>kubectl</code> when Kubernetes has such a nice HTTP API&hellip;</p>&mdash; Ivan Pedrazas (@ipedrazas) <a href="https://twitter.com/ipedrazas/status/740904502845411328">June 9, 2016</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>One thing that I hope it&rsquo;s clear it&rsquo;s that kubectl is designed to be used by people and HTTP API is designed to be used by code. In fact, if you look at the <a href="http://kubernetes.io/docs/api/">documentation</a> you will see that there&rsquo;s a list of different APIs and kubectl is under <code>kubectl CLI</code>, this is the list of all the kubernetes APIs:</p>

<ul>
<li>Kubernetes API</li>
<li>Extension API</li>
<li>Autoscaling API</li>
<li>Batch API</li>
<li>kubectl CLI</li>
</ul>

<p>So, let&rsquo;s see what these differences are!</p>

<p>In order to create this test, I&rsquo;ve spun a new cluster in AWS. To be able to make remote calls to the API server you either need the token or the user and password for the basic auth:</p>

<pre><code>root@ip-172-20-0-9:~# cat /srv/kubernetes/basic_auth.csv
PFK15d8JoTczqb3T,admin,admin

# We need to base64 encode the user/password

echo -n &quot;admin:PFK15d8JoTczqb3T&quot; | base64

root@ip-172-20-0-9:~# cat /srv/kubernetes/known_tokens.csv
iHNCmbTQCM4DRoN66PwEDqTFo2RA7JtJ,admin,admin
59OcyDFhgBlqutaWzU7jxxMSAbVQs3oU,kubelet,kubelet
jCbn8QSROs0gE525I7MIl0G1V7TEsXT4,kube_proxy,kube_proxy
</code></pre>

<p><strong>Token:</strong> <code>iHNCmbTQCM4DRoN66PwEDqTFo2RA7JtJ,admin,admin</code></p>

<p><strong>Basic Auth:</strong> <code>YWRtaW46UEZLMTVkOEpvVGN6cWIzVA==</code></p>

<p><strong>API_SERVER</strong>: <code>https://52.51.69.149</code></p>

<p>Let&rsquo;s export these values so we can re-use them easily:</p>

<pre><code>export TOKEN=iHNCmbTQCM4DRoN66PwEDqTFo2RA7JtJ
export AUTH=YWRtaW46UEZLMTVkOEpvVGN6cWIzVA==
export API_SERVER=https://52.51.69.149
</code></pre>

<p>Let&rsquo;s test that the authentication works:</p>

<pre><code>-&gt; % curl -k -X GET -H &quot;Authorization: Bearer $TOKEN&quot; $API_SERVER
    {
      &quot;paths&quot;: [
        &quot;/api&quot;,
        &quot;/api/v1&quot;,
        &quot;/apis&quot;,
        &quot;/apis/apps&quot;,
        &quot;/apis/apps/v1alpha1&quot;,
        &quot;/apis/autoscaling&quot;,
        &quot;/apis/autoscaling/v1&quot;,
        &quot;/apis/batch&quot;,
        &quot;/apis/batch/v1&quot;,
        &quot;/apis/batch/v2alpha1&quot;,
        &quot;/apis/extensions&quot;,
        &quot;/apis/extensions/v1beta1&quot;,
        &quot;/apis/policy&quot;,
        &quot;/apis/policy/v1alpha1&quot;,
        &quot;/apis/rbac.authorization.k8s.io&quot;,
        &quot;/apis/rbac.authorization.k8s.io/v1alpha1&quot;,
        &quot;/healthz&quot;,
        &quot;/healthz/ping&quot;,
        &quot;/logs/&quot;,
        &quot;/metrics&quot;,
        &quot;/swaggerapi/&quot;,
        &quot;/ui/&quot;,
        &quot;/version&quot;
      ]
    }
</code></pre>

<p>We will do basic auth also, for completion:</p>

<pre><code>curl -k -X GET -H &quot;Authorization: Basic $AUTH&quot; $API_SERVER
</code></pre>

<h3>List of Nodes</h3>

<p>Kubectl:</p>

<pre><code>kubectl get nodes
</code></pre>

<p>API:</p>

<pre><code>curl -k -X GET -H &quot;Authorization: Bearer $TOKEN&quot; $API_SERVER/api/v1/nodes
</code></pre>

<p>If you have <code>jq</code> this command will be more useful:</p>

<pre><code>curl -k -X GET -H &quot;Authorization: Bearer $TOKEN&quot; $API_SERVER/api/v1/nodes | jq '.items[].status.addresses
</code></pre>

<p>Let&rsquo;s get a list of pods:</p>

<pre><code>kubectl get pods
</code></pre>

<p>This command returns nothing because we haven&rsquo;t created a single object yet&hellip; but, we can do:</p>

<pre><code>kubectl get pods --all-namespaces


NAMESPACE     NAME                                                               READY     STATUS             RESTARTS   AGE
kube-system   elasticsearch-logging-v1-7n3fn                                     1/1       Running            0          1h
kube-system   elasticsearch-logging-v1-qcr9m                                     1/1       Running            0          1h
kube-system   fluentd-elasticsearch-ip-172-20-0-166.eu-west-1.compute.internal   1/1       Running            0          1h
kube-system   fluentd-elasticsearch-ip-172-20-0-167.eu-west-1.compute.internal   1/1       Running            0          1h
kube-system   heapster-v1.1.0.beta2-2783873945-91yz7                             4/4       Running            0          1h
kube-system   kibana-logging-v1-f4q1e                                            0/1       CrashLoopBackOff   16         1h
kube-system   kube-proxy-ip-172-20-0-166.eu-west-1.compute.internal              1/1       Running            0          1h
kube-system   kube-proxy-ip-172-20-0-167.eu-west-1.compute.internal              1/1       Running            0          1h
kube-system   kubernetes-dashboard-v1.1.0-beta1-imh41                            1/1       Running            0          1h
kube-system   monitoring-influxdb-grafana-v3-12tud                               2/2       Running            0          1h
</code></pre>

<p>Excellent, let&rsquo;s do the http query now:</p>

<pre><code>curl -k -X GET -H &quot;Authorization: Bearer $TOKEN&quot; $API_SERVER/api/v1/pods
</code></pre>

<p>Result is pretty large, so, <a href="https://gist.github.com/ipedrazas/0baf49dd82db6730db8fab9816353d3c">let&rsquo;s gist it</a>:</p>

<pre><code>{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;selfLink&quot;: &quot;/api/v1/pods&quot;,
    &quot;resourceVersion&quot;: &quot;1172&quot;
  },
  &quot;items&quot;: [
    {
     &quot;metadata&quot;: {
     &quot;name&quot;: &quot;elasticsearch-logging-v1-7n3fn&quot;,
     &quot;generateName&quot;: &quot;elasticsearch-logging-v1-&quot;,
     &quot;namespace&quot;: &quot;kube-system&quot;,
     &quot;selfLink&quot;: &quot;/api/v1/namespaces/kube-system/pods/elasticsearch-logging-v1-7n3fn&quot;,
     &quot;uid&quot;: &quot;19617fb6-2e4d-11e6-a8cc-0a800fdf3429&quot;,
     ...
</code></pre>

<p>Ok, let&rsquo;s create a namespace, then. The namespace will be defined in a file <code>new_namespace.yaml</code> with the content:</p>

<pre><code>apiVersion: v1
kind: Namespace
metadata:
  name: api-vs-kubectl
</code></pre>

<p>All the files used in this post can be found in <a href="https://github.com/ipedrazas/k8s.uk/tree/master/code/api-vs-kubelet">our github repo</a>
Now, let&rsquo;s create the namespace:</p>

<pre><code>kubectl create -f new_namespace.yaml
</code></pre>

<p>Now via HTTP API</p>

<pre><code>curl -k -H &quot;Content-Type: application/yaml&quot; -H &quot;Authorization: Bearer $TOKEN&quot; -XPOST -d&quot;$(cat api_ns.yaml)&quot; $API_SERVER/api/v1/namespaces
{
  &quot;kind&quot;: &quot;Namespace&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;name&quot;: &quot;api&quot;,
    &quot;selfLink&quot;: &quot;/api/v1/namespaces/api&quot;,
    &quot;uid&quot;: &quot;aee75ba2-2e5a-11e6-a8cc-0a800fdf3429&quot;,
    &quot;resourceVersion&quot;: &quot;1421&quot;,
    &quot;creationTimestamp&quot;: &quot;2016-06-09T15:56:09Z&quot;
  },
  &quot;spec&quot;: {
    &quot;finalizers&quot;: [
      &quot;kubernetes&quot;
    ]
  },
  &quot;status&quot;: {
    &quot;phase&quot;: &quot;Active&quot;
  }
</code></pre>

<p>Now, let&rsquo;s create some containers:</p>

<pre><code>kubectl create -f kubectl_nginx.yaml --namespace=kubectl
</code></pre>

<p>With our API:</p>

<pre><code>curl -k -H &quot;Content-Type: application/yaml&quot; -H &quot;Authorization: Bearer $TOKEN&quot; -XPOST -d&quot;$(cat api_nginx.yaml)&quot; $API_SERVER/api/v1/namespaces/api/replicationcontrollers
</code></pre>

<p>Now, if we pull all the pods we will see that we have the same exepected results:</p>

<pre><code>NAMESPACE     NAME                                                               READY     STATUS             RESTARTS   AGE
kube-system   elasticsearch-logging-v1-7n3fn                                     1/1       Running            0          1h
kube-system   elasticsearch-logging-v1-qcr9m                                     1/1       Running            0          1h
kube-system   fluentd-elasticsearch-ip-172-20-0-166.eu-west-1.compute.internal   1/1       Running            0          1h
kube-system   fluentd-elasticsearch-ip-172-20-0-167.eu-west-1.compute.internal   1/1       Running            0          1h
kube-system   heapster-v1.1.0.beta2-2783873945-91yz7                             4/4       Running            0          1h
kube-system   kibana-logging-v1-f4q1e                                            0/1       CrashLoopBackOff   25         1h
kube-system   kube-proxy-ip-172-20-0-166.eu-west-1.compute.internal              1/1       Running            0          1h
kube-system   kube-proxy-ip-172-20-0-167.eu-west-1.compute.internal              1/1       Running            0          1h
kube-system   kubernetes-dashboard-v1.1.0-beta1-imh41                            1/1       Running            0          1h
kube-system   monitoring-influxdb-grafana-v3-12tud                               2/2       Running            0          1h
kubectl       nginx-we1fb                                                        1/1       Running            0          6m
api           nginx-7nnad                                                        1/1       Running            0          46s
</code></pre>

<p>It&rsquo;s clear that the CRUD is covered by both, the API and kubectl, let&rsquo;s scale up/down pods:</p>

<pre><code>kubectl scale rc nginx --replicas=3 --namespace=kubectl
NAME          READY     STATUS    RESTARTS   AGE
nginx-onnme   1/1       Running   0          8s
nginx-p3zwa   1/1       Running   0          8s
nginx-we1fb   1/1       Running   0          8m
</code></pre>

<p>With the API, we&rsquo;re using PUT, that updates the object, so, we have to re-submit the modified object</p>

<pre><code>curl -k -H &quot;Content-Type: application/yaml&quot; -H &quot;Authorization: Bearer $TOKEN&quot; -XPUT -d&quot;$(cat api_nginx-3.yaml)&quot; $API_SERVER/api/v1/namespaces/api/replicationcontrollers/nginx
</code></pre>

<p>What about watching resources for changes?</p>

<pre><code>watch kubectl get pods
</code></pre>

<p>With the API:</p>

<pre><code>curl -k -X GET -H &quot;Authorization: Bearer $TOKEN&quot;   $API_SERVER/api/v1/pods?watch=true
</code></pre>

<p>In summary, kubectl is a great tool to interact with kubernetes, but remember that there&rsquo;s also a fantastic API that allows you to interact with the cluster also.</p>

<p>What are the main differences? Well, a person should use <code>kubectl</code> but a system, or an application would use the API. In fact, if you&rsquo;re making a tool that interacts with kubernetes and you&rsquo;re using <code>kubectl</code> under the hood, I bet it&rsquo;s because you feel more comfortable with kubectl and not so much with the REST API&hellip; But nothing comes free, you trade the knowledge you have of a tool by having to parse text instead of clearly defined objects that the API should return.</p>

<p>Truth is, that the API documentation is not great either, so&hellip; maybe we should ask to have a bunch of examples that use the API so people can learn faster :)</p>

  <p class="text-right"><a class="btn btn-default" href="kubectl-vs-http-api.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="accessing-kubernetes-apiserver.html" href="accessing-kubernetes-apiserver.html">Accessing Kubernetes Apiserver</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2016-06-06</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/security.html">security</a>
  
  <a class="label label-info" href="/tag/tokens.html">tokens</a>
  
  
  </p>

  <p>The process to access the api server is very simple. The <code>apiserver</code> has a flag that defines what type of access is desired:</p>

<ul>
<li><code>--authorization-mode=AlwaysDeny</code> blocks all requests (used in tests).</li>
<li><code>--authorization-mode=AlwaysAllow</code> allows all requests; use if you don’t need authorization.</li>
<li><code>--authorization-mode=ABAC</code> allows for user-configured authorization policy. ABAC stands for Attribute-Based Access Control.</li>
<li><code>--authorization-mode=Webhook</code> allows for authorization to be driven by a remote service using REST.</li>
</ul>

<p>To allow Basic Auth and/or tokens, we have to select <code>ABAC</code>.</p>

<h2>Access</h2>

<p>To access the API server via tokens there are 2 things that need to be defined: the token/user and what the user is allowed to do. Tokens are defined in a file, policies are defined in a different file.</p>

<p>These configuration files have to be passed to the <code>kube-apiserver</code> using the following parameters:</p>

<ul>
<li><code>--authorization-mode=ABAC</code></li>
<li><code>--token-auth-file=/srv/kubernetes/auth_tokens.csv</code></li>
<li><code>--authorization-policy-file=/srv/kubernetes/auth-policy.json</code></li>
</ul>

<p>If you want to allow Basic Auth, you have to specify the file containing the</p>

<ul>
<li><code>--basic-auth-file=/srv/kubernetes/basic_auth.csv</code></li>
</ul>

<p>Example of running the apiserver with those flags:</p>

<pre><code>/bin/sh -c /usr/local/bin/kube-apiserver --address=127.0.0.1 --etcd-servers=http://127.0.0.1:4001
--admission-control=NamespaceLifecycle,LimitRanger,SecurityContextDeny,ServiceAccount,PersistentVolumeLabel,ResourceQuota
--token-auth-file=/srv/kubernetes/auth_tokens.csv
--authorization-mode=ABAC
--authorization-policy-file=/srv/kubernetes/auth-policy.json
--basic-auth-file=/srv/kubernetes/basic_auth.csv
</code></pre>

<p>Here are examples of the files used by the <code>apiserver</code>:</p>

<p>Example of tokens in <code>auth_tokens.csv</code>:</p>

<pre><code>Wx4WOTOmFoY5yXaoMPtHdnKeFLPYeBBL,admin,admin
jD34eFwNrJo9urd7QWLMALOjK7R58j1g,kubelet,kubelet
PxgQ4vSloVIhfFwx9WYaj8uke93JVBHh,kube_proxy,kube_proxy
i2TgpiZFZQNkIydDZzVkxmTHl3Q2hPNn,ivan,ivan
</code></pre>

<p>Example of user/password for Basic Auth <code>basic_auth.csv</code>:</p>

<pre><code>GGIfwZn63i3NMWeN,admin,admin
</code></pre>

<p>Example of authentication policy file  <code>auth-policy.json</code></p>

<pre><code>{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;:&quot;ivan&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;:&quot;admin&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;:&quot;kubelet&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;:&quot;kube_proxy&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;:&quot;kubecfg&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;user&quot;:&quot;client&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
{&quot;apiVersion&quot;: &quot;abac.authorization.kubernetes.io/v1beta1&quot;, &quot;kind&quot;: &quot;Policy&quot;, &quot;spec&quot;: {&quot;group&quot;:&quot;system:serviceaccounts&quot;, &quot;namespace&quot;: &quot;*&quot;, &quot;resource&quot;: &quot;*&quot;, &quot;apiGroup&quot;: &quot;*&quot;, &quot;nonResourcePath&quot;: &quot;*&quot;}}
</code></pre>

<h2>Testing</h2>

<p>If you want to test the access, you can try the following commands:</p>

<p>Access using Basic Auth:</p>

<pre><code>curl -k -X GET -H   &quot;Authorization: Basic YWRtaW46R0dJZndabjYzaTNOTVdlTg==&quot;   https://$API_SERVER
</code></pre>

<p>Note that the string <code>YWRtaW46R0dJZndabjYzaTNOTVdlTg==</code> is the result of</p>

<pre><code>echo -n &quot;admin:GGIfwZn63i3NMWeN&quot; | base64
</code></pre>

<p>Access using tokens:</p>

<pre><code>curl -k -X GET -H &quot;Authorization: Bearer i2TgpiZFZQNkIydDZzVkxmTHl3Q2hPNn&quot;    https://$API_SERVER
</code></pre>

<h3>Policy File Format</h3>

<p>For mode  <strong>ABAC</strong>, also specify <code>--authorization-policy-file=SOME_FILENAME</code>.
The file format is one JSON object per line. There should be no enclosing list or map, just one map per line.
Each line is a “policy object”. A policy object is a map with the following properties:</p>

<ul>
<li>Versioning properties:

<ul>
<li><strong>apiVersion</strong>, type string; valid values are “abac.authorization.kubernetes.io/v1beta1”. Allows versioning and conversion of the policy format.</li>
<li><strong>kind</strong>, type string: valid values are “Policy”. Allows versioning and conversion of the policy format.</li>
</ul></li>
<li>spec property set to a map with the following properties:

<ul>
<li>Subject-matching properties:

<ul>
<li><strong>user</strong>, type string; the user-string from <code>--token-auth-file</code>. If you specify user, it must match the username of the authenticated user. * matches all requests.</li>
<li><strong>group</strong>, type string; if you specify group, it must match one of the groups of the authenticated user. * matches all requests.</li>
</ul></li>
<li><strong>readonly</strong>, type boolean, when true, means that the policy only applies to get, list, and watch operations.</li>
<li>Resource-matching properties:

<ul>
<li><strong>apiGroup</strong>, type string; an API group, such as extensions. * matches all API groups.</li>
<li><strong>namespace</strong>, type string; a namespace string. * matches all resource requests.</li>
<li><strong>resource</strong>, type string; a resource, such as pods. * matches all resource requests.</li>
</ul></li>
<li>Non-resource-matching properties:

<ul>
<li>nonResourcePath, type string; matches the non-resource request paths (like /version and /apis). * matches all                * <strong>non-resource requests</strong>. /foo/* matches /foo/ and all of its subpaths.</li>
</ul></li>
</ul></li>
</ul>

  <p class="text-right"><a class="btn btn-default" href="accessing-kubernetes-apiserver.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="kubernetes-play.html" href="kubernetes-play.html">Kubernetes Play</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2016-05-10</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/kubernetes.html">kubernetes</a>
  
  <a class="label label-info" href="/tag/tools.html">tools</a>
  
  <a class="label label-info" href="/tag/playground.html">playground</a>
  
  <a class="label label-info" href="/tag/test.html">test</a>
  
  
  </p>

  <p>Recently we were talking about building a kubernetes cluster to let people play and familiarise with Kuberentes. However, building such cluster is not an easy task. Security was our main concern. Not because kubernetes is not secure enough, but because having a kubernetes cluster exposed to the public could be dangerous.</p>

<p>While thinking of the different aspects we should cover and build I remembered a website called &ldquo;<a href="https://www.katacoda.com">Katacoda</a>&rdquo; where you could learn Docker. I went there and sure enough, Ben had built a <a href="https://www.katacoda.com/courses/kubernetes">Kubernetes playground</a>!!!</p>

<p>So, if you want to familiarise with Kubernetes, I strongly advise you to go there and follow the different tutorials. The great thing about Katacoda is that you do not need anything special, just a good old browser (not too old, please).</p>

<p align="center"><img src="/static/katacoda.png" /></p>

  <p class="text-right"><a class="btn btn-default" href="kubernetes-play.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="using-kong-with-kubernetes.html" href="using-kong-with-kubernetes.html">Using Kong with Kubernetes</a></h1>

  <p>
  
  <span class="label label-default">by Álex González</span>
  

  
  <span class="label label-default">2015-12-17</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/kong.html">kong</a>
  
  <a class="label label-info" href="/tag/microservices.html">microservices</a>
  
  
  </p>

  <p>If you don&rsquo;t know about <a href="https://getkong.org">Kong</a> yet, you should take a look. It&rsquo;s an Open Source API Gateway, they define themselves as: &ldquo;The open-source management layer for APIs, delivering high performance and reliability.&rdquo; and they are quite right.</p>

<p>I was playing with Kong lately at work (<a href="http://jobandtalent.com">jobandtalent.com</a>, we are hiring!) and I think that it could be pretty awesome as a entry layer to your microservices platform running in Kubernetes.</p>

<p>For the sake of simplicity I will not run Kong in Kubernetes, but it shouldn&rsquo;t be so difficult since <a href="https://getkong.org/install/">they already provide Docker images</a>. Also, running Kong on the same cluster you will be able to use internal networking between pods: win-win.</p>

<p>So, what will I show?</p>

<ul>
<li>I will deploy a Kubernetes with 2 pods (our 2 microservices) &amp;</li>
<li>I will install Kong locally and configure it to point to this 2 services.</li>
</ul>

<h2>Go &amp; packing</h2>

<p>I&rsquo;ve created a small Go app that will show the value of an environment variable when you <code>GET /</code>:</p>

<pre><code>package main

import (
  &quot;fmt&quot;
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;os&quot;
)

func main() {
  http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, os.Getenv(&quot;TEST_RESULT&quot;))
  })

  log.Fatal(http.ListenAndServe(&quot;:8080&quot;, nil))
}
</code></pre>

<p>Now we will build the application to later pack it in our image. Remember that if you are in Mac you will need to cross-compile the app to work on Linux:</p>

<pre><code>$ GOOS=linux go build
</code></pre>

<p>We can pack it into our images now. For doing so we need a <code>Dockerfile</code>. It&rsquo;s a simple binary, so the <code>Dockerfile</code> is not complex at all:</p>

<pre><code>FROM scratch
ADD app /
ENTRYPOINT [&quot;/app&quot;]
</code></pre>

<p>Cool! What can we do now with our shiny image? Yes, you are right! Push it to the hub:</p>

<pre><code>$ docker build -t agonzalezro/kong-test .
$ docker push agonzalezro/kong-test
</code></pre>

<h2>k8s</h2>

<p>We have our image on the registry and all we need now is running it on Kubernetes. I am using <a href="https://cloud.google.com/container-engine/">Google Container Engine</a> for deploying this, but you can use whatever you prefer.</p>

<p>Let&rsquo;s create our RCs &amp; services:</p>

<pre><code># rc1.yml
apiVersion: v1
kind: ReplicationController
metadata:
  name: api1
spec:
  selector:
    name: api
    version: first
  template:
    metadata:
      labels:
        name: api
        version: first
    spec:
      containers:
        - name: app
          image: agonzalezro/kong-test
          env:
            - name: TEST_RESULT
              value: &quot;This is the first app&quot;

# rc2.yml
apiVersion: v1
kind: ReplicationController
metadata:
  name: api2
spec:
  selector:
    name: api
    version: second
  template:
    metadata:
      labels:
        name: api
        version: second
    spec:
      containers:
        - name: app
          image: agonzalezro/kong-test
          env:
            - name: TEST_RESULT
              value: &quot;Second!&quot;

# svc1.yml
apiVersion: v1
kind: Service
metadata:
  name: app1-svc
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    name: api
    version: first

# svc2.yml
apiVersion: v1
kind: Service
metadata:
  name: app2-svc
spec:
  type: LoadBalancer
  ports:
    - port: 80
      targetPort: 8080
  selector:
    name: api
    version: second
</code></pre>

<p>And now run it:</p>

<pre><code>$ kubectl create -f rc1.yml -f rc2.yml -f svc1.yml -f svc2.yml
</code></pre>

<p>Wait for the service and the pods to be ready and check their IPS:</p>

<pre><code>$ kubectl get services
NAME         CLUSTER_IP      EXTERNAL_IP      PORT(S)   SELECTOR                  AGE
app1-svc     10.159.242.86   130.211.89.175   80/TCP    name=api,version=first    17m
app2-svc     10.159.246.93   104.155.53.175   80/TCP    name=api,version=second   17m
kubernetes   10.159.240.1    &lt;none&gt;           443/TCP   &lt;none&gt;                    1h
</code></pre>

<h2>Kong</h2>

<p>Follow the instruction here: <a href="https://getkong.org/install/docker/">https://getkong.org/install/docker/</a> to install Kong locally.</p>

<p>Yeah! We have it up &amp; running so let&rsquo;s point it to our shinny cluster. We need to use Kong API for that (port <code>:8001</code>):</p>

<pre><code>$ http http://dockerhost:8001/apis/ name=first upstream_url=http://130.211.89.175 request_path=/first strip_request_path=true
$ http http://dockerhost:8001/apis/ name=second upstream_url=http://104.155.53.175 request_path=/second strip_request_path=true
</code></pre>

<p>What we did here? We set up two new endpoints <code>/first</code> &amp; <code>/second</code> that are pointing to the both Kubernetes services previously created. We could have done it with DNS as well using <code>request_host</code> instead.</p>

<p>Lets call Kong on the port <code>:8000</code> to use them:</p>

<pre><code>$ http http://dockerhost:8000/first
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 21
Content-Type: text/plain; charset=utf-8
Date: Thu, 17 Dec 2015 21:43:41 GMT
Via: kong/0.5.4

This is the first app

$ http http://dockerhost:8000/second
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 7
Content-Type: text/plain; charset=utf-8
Date: Thu, 17 Dec 2015 21:43:44 GMT
Via: kong/0.5.4

Second!
</code></pre>

<p>\o/ We did it!</p>

<h2>Next steps</h2>

<p>You have Kong pointed to your cluster, now it&rsquo;s up to your imagination what to do next. I would say try to configure some rate limiting or auth, it&rsquo;s deadly simply. Check them here: <a href="https://getkong.org/plugins/">https://getkong.org/plugins/</a></p>

<p>If you have any question or you want to discuss this further let me know at <a href="https://twitter.com/agonzalezro">@agonzalezro</a>.</p>

  <p class="text-right"><a class="btn btn-default" href="using-kong-with-kubernetes.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="deploy-by-labels.html" href="deploy-by-labels.html">Deploy by Labels</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2015-12-04 15:38</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/management.html">management</a>
  
  <a class="label label-info" href="/tag/labels.html">labels</a>
  
  <a class="label label-info" href="/tag/core.html">core</a>
  
  
  </p>

  <p>Labels in kubernetes are the only way of grouping, filtering and selecting resources. In my experience, we do not use labels enough. Unlike with AWS, you can define as many labels as you want, so, why are we not truly squeezing all the potential of labels?</p>

<p>I&rsquo;d say it&rsquo;s because we&rsquo;re not use to, and because we lack clear use cases. Yes, it drills down to we getting used to organise and manage things in a specific way.</p>

<p>In my experience, deployments is one of the parts where being smart with your labels can take you a very long way.</p>

<p>Have you ever done a deployment where everything went well but for a non technical issue you had to roll back? something like &ldquo;Oh, God, that promotion cannot go live just yet&hellip; ROLLBACK! ROLLBACK!!&rdquo;</p>

<p>Labels are key/value pairs. I usually tag or label my resources with:</p>

<ul>
<li><strong>state</strong>: production, test, lab&hellip;</li>
<li><strong>version</strong>: the version of the app following <a href="http://semver.org/">SemVer</a></li>
<li><strong>channel</strong>:  &ldquo;public&rdquo;, &ldquo;internal&rdquo;, &ldquo;cannary&rdquo;</li>
<li><strong>owner</strong>: who owns the resource. this can be for making your life easier when doing interal billing, or for knowing who to get in contact with if something goes wrong with it.</li>
</ul>

<p>So, how do you deploy a new version of your application?</p>

<p>Let&rsquo;s assume the initial state is this:</p>

<ul>
<li>Replication Controller: deep-frontend, replicas: 3</li>
<li>Pod: deep-reports-38x6n (state: production, version: 1.0.7, channel: public, owner: ipedrazas)</li>
<li>Service: selector state=production, channel=public</li>
</ul>

<p>Note that your app is available through the service and the service binds to the pods that have the labels <code>state=production</code>,  <code>channel=public</code> and <code>version= 1.0.7</code>.</p>

<p>If now you deploy a new Replication controller you will have the following scenario:</p>

<ul>
<li>Replication Controller: deep-frontend, replicas: 3</li>
<li>Replication Controller: deep-frontend_new, replicas: 3</li>
<li>Pod: deep-frontend-38x6n (state: production, version: 1.0.7, channel: public, owner: ipedrazas)</li>
<li>Pod: deep-frontend_new-jag1p (state: production, version: 1.0.8, channel: public, owner: ipedrazas)</li>
<li>Service: selector state=production, channel=public, version=1.0.7</li>
</ul>

<p>You can see where I&rsquo;m going. You can then go and update a label in the service: <code>version=1.0.8</code> and your service is repointed to the new app. As you can see, the old app is still in the system, rolling back is just a matter of updating the label back to its original value.</p>

<pre><code>    kubectl label pods deep-reports-38x6n version=1.0.8 --overwrite
</code></pre>

<p>Production deployments have a very wide range of situations. Trying to find a golden rule for deployments (standarisation, standarisation) usually doesn&rsquo;t work well, so it&rsquo;s better to define certain patterns that you can adapt to your needs.</p>

<p>Labels are very powerful, and usually they&rsquo;re not used to their maximum potential. The post doesn&rsquo;t try to convince you to change your deployment strategy but to illustrate different ways of doing the same thing, and different use cases of this kubernetes artifact that can change the way you understand your landscape.</p>

<p>If you want to know a bit more about Labels, <a href="https://cloud.google.com/container-engine/docs/kubectl/label">here&rsquo;s the documentation</a>.</p>

  <p class="text-right"><a class="btn btn-default" href="deploy-by-labels.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="private-registry.html" href="private-registry.html">Private Registry</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2015-12-03 09:58</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/registry.html">registry</a>
  
  <a class="label label-info" href="/tag/core.html">core</a>
  
  
  </p>

  <p>The first time we tried to use a private registry in Kubernetes we got bitten by a weird bug: the format of the <code>.dockercfg</code>.</p>

<p>If you read the <a href="http://kubernetes.io/v1.1/docs/user-guide/images.html">documentation</a> you will see that you have to create a secret, and then use that secret in your pod definition.</p>

<p>What it seems to be missing from the docs is that the format of the json that contains the registry auth info is important.</p>

<p>This is the example in the documentation:</p>

<pre><code>$ echo $(cat ~/.dockercfg)
{ &quot;https://index.docker.io/v1/&quot;: { &quot;auth&quot;: &quot;ZmFrZXBhc3N3b3JkMTIK&quot;, &quot;email&quot;: &quot;jdoe@example.com&quot; } }
</code></pre>

<p>But we need base64 encode text:</p>

<pre><code>$ cat ~/.dockercfg | base64
eyAiaHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEvIjogeyAiYXV0aCI6ICJabUZyWlhCaGMzTjNiM0prTVRJSyIsICJlbWFpbCI6ICJqZG9lQGV4YW1wbGUuY29tIiB9IH0K
</code></pre>

<p>Finally, we create the secret definiton using the base64</p>

<pre><code>$ cat &gt; /tmp/image-pull-secret.yaml &lt;&lt;EOF
apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
data:
  .dockercfg: eyAiaHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEvIjogeyAiYXV0aCI6ICJabUZyWlhCaGMzTjNiM0prTVRJSyIsICJlbWFpbCI6ICJqZG9lQGV4YW1wbGUuY29tIiB9IH0K
type: kubernetes.io/dockercfg
EOF
</code></pre>

<p>Finally, we create the secret in the cluster</p>

<pre><code>$ kubectl create -f /tmp/image-pull-secret.yaml
secrets/myregistrykey
</code></pre>

<p>Once we have the secret, we can use that secret in our pods.</p>

<pre><code>apiVersion: v1
kind: Pod
metadata:
  name: foo
spec:
  containers:
    - name: foo
      image: janedoe/awesomeapp:v1
  imagePullSecrets:
    - name: myregistrykey
</code></pre>

<p>This is all true and good, but the detail of the format of .dockercfg is the kind of thing that will have you running around calling names. So, what&rsquo;s the problem? If you execute the first command of the post:</p>

<pre><code>$ echo $(cat ~/.dockercfg)
</code></pre>

<p>You will see that it returns 1 line. However, between catting the file and echoing the catting fo the file there&rsquo;s one little detail: that ECHO makes the file to be in one single line.</p>

<p>Now, look at this:</p>

<pre><code>-&gt; % cat .dockercfg| base64
ewoKCSJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOiB7CgkJImF2dGgiOiAiYVhCbFpISmhl
bUZ6T25Rd2REQnlNRMV5T21SdiIsCgkJImVtYWlsIjogImlwZWRyYXphc0BnbWFpbC5jb20iCgl9
Cn0=

-&gt; % echo $(cat .dockercfg) | base64
eyAiaHR0cHM6Ly9pbmRleC5kb2NrZXIuaW8vdjEvIjogeyAiYXV2aCI6ICJhWEJsWkhKaGVtRnpP
blF3ZERCeU1ERXlPbVJ2KiwgImVtYWlsIjogImlwZWRyYXphc0BnbWFpbC5jb20iIH0gfQo=
</code></pre>

<p>I&rsquo;m not sure why nobody has bothered writing this little note in the docs, but if you don&rsquo;t echo the cat, the secret will be wrong. Anyway, from now on, remember, the format of the json is important&hellip; so make sure you verify the json you&rsquo;re using is in one single line.</p>

  <p class="text-right"><a class="btn btn-default" href="private-registry.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="jobs.html" href="jobs.html">Jobs</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2015-11-30 12:08</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  
  <a class="label label-info" href="/tag/job.html">job</a>
  
  <a class="label label-info" href="/tag/core.html">core</a>
  
  
  </p>

  <p>No, this post is not about recruitment, it&rsquo;s about the <a href="https://github.com/kubernetes/kubernetes/blob/release-1.1/docs/user-guide/jobs.md"><strong>Jobs</strong> artifact</a> that was introduced with version 1.1.</p>

<p>Jobs are the way in Kubernetes of running on-off containers (or pods). Until now, to run a container you could define a pod and schedule it without a replication controller. Now, we have the concept of a &ldquo;job&rdquo;. In reality, &ldquo;Task&rdquo; would be more appropriate, but as we can see in the roadmap, scheduling jobs will come in version 1.2.</p>

<p>If we read the definition in the docs it says:</p>

<pre><code>A job creates one or more pods and ensures that a specified number of them successfully terminate. As pods successfully complete, the job tracks the successful completions. When a specified number of successful completions is reached, the job itself is complete. Deleting a Job will cleanup the pods it created.
</code></pre>

<p>So, What can we do with jobs now? One of the things we do is to run Integration Test. You deploy your artifacts: pods, replication controllers, and servcies and then, we run a job to test that everything works as expected.</p>

<p>Building a CI pipeline is hard. Using kubernetes simplifies a bit certain aspects (like the deployment) but it makes harder other bits (like knowing when everything is ready). We&rsquo;re preparing a big post about CI, so, stay tunned.</p>

<p>A job definition is very similar to a Replication controller or a Pod:</p>

<pre><code>apiVersion: extensions/v1beta1
kind: Job
metadata:
  name: pi
spec:
  selector:
    matchLabels:
      app: pi
  template:
    metadata:
      name: pi
      labels:
        app: pi
    spec:
      containers:
      - name: pi
        image: perl
        command: [&quot;perl&quot;,  &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(2000)&quot;]
      restartPolicy: Never
</code></pre>

<p>Note that the <strong>apiVersion</strong> uses <a href="https://github.com/kubernetes/kubernetes/blob/release-1.1/docs/api.md#api-groups">extensions</a>. The schema of a job will change once the scheduling features land in version 1.2, but for now, it&rsquo;s very straight forward: define the artifact kind as a job, include the pod template definition and off you go. Another thing to note is the <strong>restartPolicy</strong>, you can set it to Always, OnFailure, or Never, depending on what you think it&rsquo;s appropriate.</p>

  <p class="text-right"><a class="btn btn-default" href="jobs.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  
  <article>
  <h1><a id="kubernetes-a-blog.html" href="kubernetes-a-blog.html">Kubernetes, a blog</a></h1>

  <p>
  
  <span class="label label-default">by Ivan Pedrazas</span>
  

  
  <span class="label label-default">2015-11-26 11:57</span>
  

  
  <a class="label label-success" href="/category/kubernetes.html">kubernetes</a>
  

  
  </p>

  <p>One of the things that I really missed during my journey to Docker was to have a place to put all the notes, posts and leassons learnt&hellip; which end up scattered all over gists, posts and text files all over the place.</p>

<p>Now with Kubernetes I thought&hellip; perhaps I should start being a bit more organised, and since I &ldquo;had&rdquo; to register this domain, I thought, you know what, it would be great if apart from me, anyone else could contribute to it.
rsome, so, I decided to go for a very open attempt.</p>

<p>So, if you want to publish a post in this blog, just fork and send a PR!</p>

<p>Let&rsquo;s make the Kubernetes community even more awesome!</p>

  <p class="text-right"><a class="btn btn-default" href="kubernetes-a-blog.html#disqus_thread">Permalink</a></p>
  </article>
  <hr>
  

  

   
</div>

<div id="list-of-articles" class="hidden-sm hiddem-md col-lg-3">
  <div class="list-group">
    
    
    <a class="list-group-item" href="#kubectl-vs-http-api.html">Kubectl vs HTTP API</a>
    
    
    
    <a class="list-group-item" href="#accessing-kubernetes-apiserver.html">Accessing Kubernetes Apiserver</a>
    
    
    
    <a class="list-group-item" href="#kubernetes-play.html">Kubernetes Play</a>
    
    
    
    <a class="list-group-item" href="#using-kong-with-kubernetes.html">Using Kong with Kubernetes</a>
    
    
    
    <a class="list-group-item" href="#deploy-by-labels.html">Deploy by Labels</a>
    
    
    
    <a class="list-group-item" href="#private-registry.html">Private Registry</a>
    
    
    
    <a class="list-group-item" href="#jobs.html">Jobs</a>
    
    
    
    <a class="list-group-item" href="#kubernetes-a-blog.html">Kubernetes, a blog</a>
    
    
    <a class="list-group-item text-center active" href="/archive.html">Show more</a>
  </div>
  
  <a class="label label-info" href="/tag/security.html">security</a>
  
  <a class="label label-info" href="/tag/tokens.html">tokens</a>
  
  <a class="label label-info" href="/tag/api.html">api</a>
  
  <a class="label label-info" href="/tag/utils.html">utils</a>
  
  <a class="label label-info" href="/tag/job.html">job</a>
  
  <a class="label label-info" href="/tag/core.html">core</a>
  
  <a class="label label-info" href="/tag/kubernetes.html">kubernetes</a>
  
  <a class="label label-info" href="/tag/tools.html">tools</a>
  
  <a class="label label-info" href="/tag/playground.html">playground</a>
  
  <a class="label label-info" href="/tag/test.html">test</a>
  
  <a class="label label-info" href="/tag/kong.html">kong</a>
  
  <a class="label label-info" href="/tag/microservices.html">microservices</a>
  
  <a class="label label-info" href="/tag/management.html">management</a>
  
  <a class="label label-info" href="/tag/labels.html">labels</a>
  
  <a class="label label-info" href="/tag/registry.html">registry</a>
  
  <a class="label label-info" href="/tag/usecase.html">usecase</a>
  
  <a class="label label-info" href="/tag/prod.html">prod</a>
  
</div>


    </div>
    
<div class="container col-md-10 col-md-offset-1 col-lg-8 col-lg-offset-2">
  <div class="text-center">
    <p>
    k8s.uk is made with
    <span class="glyphicon glyphicon-heart"></span> by
    <a href="http://twitter.com/agonzalezro">@agonzalezro</a> and <a href="https://twitter.com/ipedrazas">@ipedrazas</a>
    </p>
  </div>
</div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="//getbootstrap.com/dist/js/bootstrap.min.js"></script>

    

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-78960031-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
  

  </body>
</html>
